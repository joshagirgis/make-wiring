#include <Arduino.h>
#include <Wire.h>
#include <TinyGPSplusplus.h>  //gps lib
#include <ReceiveOnlySoftwareSerial.h>
#include <INA219.h>
#include <EEPROM.h> 
#include <CN0349.h>
#include <SHT20.h>
#include <avr/io.h> 
#include <avr/sleep.h>
#include <avr/wdt.h>
#include <avr/power.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdlib.h>
#define SW_Serial Serial1  
ReceiveOnlySoftwareSerial gpsSer(6); 	// RX PB2 converts to pin6 in for atmega644pa Arduino variant
TinyGPSPlus gps; 						//intialize GPS
SHT20 TH;
INA219 CV;

void i2C_Scanner() { //scans i2c bus line
  byte error, address;
  int nDevices;
  Serial.println("Scanning...");
  nDevices = 0;
  for (address = 1; address < 127; address++ ) {
    // The i2c_scanner uses the return value of
    // the Write.endTransmisstion to see if
    // a device did acknowledge to the address.
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) {
      Serial.print("I2C device found at address 0x");
      if (address < 16)
        Serial.print("0");
      Serial.print(address, HEX);
      Serial.println("  !");
      nDevices++;
    }
    else if (error == 4) {
      Serial.print("Unknown error at address 0x");
      if (address < 16)
        Serial.print("0");
      Serial.println(address, HEX);
    }
  }
  if (nDevices == 0)
    Serial.println("No I2C devices found\n");
  else
    Serial.println("done\n");
};

String gpsSensor() {
  String deg_latCoord;
  String deg_lonCoord;
  String latCoord;
  String lonCoord;
  String latCoord1;
  String lonCoord1;
  double decimal_degrees;
  double minutes_lon;
  double minutes_lat;
  double seconds;
  double tenths;
  int lat_degr;
  int lon_degr;
  String coord;
  unsigned long howLong = 3000;
  unsigned long startedAt = millis();
  while (millis() - startedAt < howLong) {
    if (gpsSer.available()) {
      char c = gpsSer.read();
      gps.encode(c);
      //Serial.write(c);
      if (gps.location.isUpdated()) {
        deg_latCoord = String(gps.location.lat(), 10);
        deg_lonCoord = String(gps.location.lng(), 10);
        //lat
        decimal_degrees = deg_latCoord.toFloat();
        lat_degr = int(decimal_degrees);
        minutes_lat = fabs(((decimal_degrees) - (lat_degr)) * 60.0);

        latCoord1 = String(int(lat_degr)) + String((minutes_lat), 4);
        //lon
        decimal_degrees = deg_lonCoord.toFloat();
        lon_degr = int(decimal_degrees);
        minutes_lon = fabs(((decimal_degrees) - (lon_degr)) * 60.0);

        lonCoord1 = String(int(lon_degr)) + String((minutes_lon), 4);
        coord = latCoord1 + "_" + lonCoord1;
        return coord;
        break;

      }
    }
  }
  // transmitGPS = "4488.7667_-6870.3348";
}

bool SendModemCommand(String command, String expectedResp, int msToWait, String& respOut) {
  int cmd_timeout = 0;
  SW_Serial.print(command);
  delay(msToWait);

  // wait for data to become available, but timeout eventually if no response is received
  while (!SW_Serial.available()) {
    cmd_timeout++;
    if (cmd_timeout == 1000) {
      Serial.println("command timeout");
      return false;
    }
    delay(10);
  }

  // read response from modem
  String resp = "";
  respOut = "";
  while (SW_Serial.available() > 0) {
    resp += char(SW_Serial.read());
    if (resp.endsWith(expectedResp)) {
      respOut = resp;
      while (SW_Serial.available() > 0)
        respOut += char(SW_Serial.read());  // append remaining response characters (if any)
      return true;
    }
  }
  respOut = resp;
  return false;
}

void ConsumeModemResponse() { // empty read buffer
  while (SW_Serial.available())
    SW_Serial.read();
}

// repeatedly sends command to the modem until correct response is received
void WaitForResponse(String command, String expectedResp, int msToWait, String& respOut) {
  bool isExpectedResp;
  do {
    isExpectedResp = SendModemCommand(command, expectedResp, msToWait, respOut);
    Serial.println(respOut);
    SW_Serial.flush();        // just in case any characters weren't transmitted
    ConsumeModemResponse();   // just in case any characters remain in RX buffer
  }
  while (!isExpectedResp);
}

String GetModemResponse() {// returns modem response as a String
  String resp = "";
  while (SW_Serial.available() > 0) {
    resp += char(SW_Serial.read());
  }
  return resp;
}

int PrintModemResponse() {// consumes and prints modem response
  String resp = "";
  while (SW_Serial.available() > 0) {
    // read incoming modem response into temporary string
    resp += char(SW_Serial.read());
  }
  Serial.println(resp);
  //return number of characters in modem response buffer -- should be zero, but some may have come in since last test
  return SW_Serial.available();
}

String splitString(String data, char separator, int index) {
  int found = 0;
  int strIndex[] = {0, -1};
  int maxIndex = data.length() - 1;
  for (int i = 0; i <= maxIndex && found <= index; i++) {
    if (data.charAt(i) == separator || i == maxIndex) {
      found++;
      strIndex[0] = strIndex[1] + 1;
      strIndex[1] = (i == maxIndex) ? i + 1 : i;
    }
  }
  return found > index ? data.substring(strIndex[0], strIndex[1]) : "";
}

String getExoData(String alias, String CIK) {  //get data alias from exosite
  /*/////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
  /*/////////////////////////////////////////*VERY IMPORTANT NOTE*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
  /*/////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
  /*
     NOTE: In order to receive the entire HTTP GET message, you must adjust the size of the Arduino RX buffer.
     The file is located at:

     C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino\HardwareSerial.h

     Edit this file as administrator, changing the value in the line:

     #define SERIAL_RX_BUFFER_SIZE 64

     to a larger value, such as:

     #define SERIAL_RX_BUFFER_SIZE 512

     Keep in mind the size of your program and the size of the information you are receiving when selecting
     your value!

     This example has been tested as working with a value of 512 bytes on an Arduino Leonardo R3
  */
  /*/////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
  /*/////////////////////////////////////////*VERY IMPORTANT NOTE*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
  /*/////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
  String modemResponse = "";
  // Setup HTTP connection to exosite
  SendModemCommand("AT^SISC=0\r", "OK", 500, modemResponse); // Close connection
  SendModemCommand("AT^SICA=1,3\r", "OK", 500, modemResponse);
  SendModemCommand("AT^SISO=0\r", "OK", 500, modemResponse);
  SendModemCommand("AT^SISW=0,250\r", "^SISW: 0,250,0", 500, modemResponse);  // Set command length to total number of characters of the POST command http_command

  String http_command;
  Serial.println("Getting data from exosite");
  // Build string to send to exosite
  http_command = "GET /onep:v1/stack/alias?" + alias + " HTTP/1.1\n"; //end data to exosite with GET command
  http_command += "Accept: application/x-www-form-urlencoded; charset=utf-8\n";
  http_command += "Accept-Encoding: gzip, deflate\n";
  http_command += "Host: m2.exosite.com\n";
  http_command += "Connection: Close\n";
  http_command += "X-Exosite-CIK: " + CIK + "\n\n\n";
  Serial.print(http_command);
  WaitForResponse(http_command, "^SISW: 0,1", 500, modemResponse);
  WaitForResponse("AT^SISR=0,1000\r", "^SISR: 0,", 500, modemResponse);
  String dataResponse = modemResponse;
  //dataResponse.remove(0, 138);
  while (PrintModemResponse() > 0);
  // Could put code here to check for data transmission error "+CME ERROR"
 // WaitForResponse("AT^SISC=0\r", "OK", 500, modemResponse); // Close connection*/

  // Print output
  Serial.println("\n");
  String s = "Information taken from exosite.";
  Serial.println(s);
  //dataResponse = splitString(splitString(dataResponse, '&', 0), 'O', 0); //split at OK
  //dataResponse.remove(0, alias.length() + 3);
  //dataResponse.trim();  //get rid of whitespace
  return dataResponse;
}

void modemSetup() {
  String modemResponse = ""; // Modem responce to a command
  // initialize serial debug communication with PC over USB connection
  while (!Serial) ; // wait for serial debug port to connect to PC
  for (int q = 5; q > 0; q--) {
    Serial.println(q, DEC);
    delay(250);
  }
  Serial.println("Socket Dial To Send data to Exosite");
  // Start cellular modem
  Serial.println("Starting Cellular Modem");

  digitalWrite(10, LOW); //ON_OFF has internal 200k pullup resistor and needs to be driven low for >1s, don't accept default
  // Configure I/O pin 12 as output
  pinMode(10, OUTPUT);
  digitalWrite(10, LOW);  // Turn on Skywire modem
  delay(1200); // modem requires >1s pulse
  pinMode(10, INPUT);  // Return I/O pin 12 to input/hi-Z state
  
  delay(30100); // Wait > 30 seconds for initialization

  // Initialize serial port to communicate with modem
  Serial.println("Initializing modem COM port");
  SW_Serial.begin(115200);
  
  while (!SW_Serial) ;  // send "AT" command to confirm modem is turned on
  Serial.println("Test AT command");
  WaitForResponse("AT\r", "OK", 100, modemResponse);
  Serial1.print("AT^SCFG=\"GPIO/mode/SYNC\",\"std\"\r");
  Serial1.print("AT^SLED=1\r");
  // turn on echo for Cat 1 modem
  WaitForResponse("ATE1\r", "OK", 500, modemResponse);
  Serial.println("Reseting modem");
  WaitForResponse("AT+SOFTRESET\r", "OK", 500, modemResponse);  // Soft reset of modem
  WaitForResponse("AT+CEREG=0\r", "OK", 500, modemResponse);  // turn off URC (unsolicited result code) messages for Cat 1 modem
  WaitForResponse("AT+CMEE=2\r", "OK", 1000, modemResponse);  // turn on verbose error messages
  // Setup PDP context
  Serial.println("Setting up PDP context");
  SendModemCommand("AT^SISC=0\r", "OK", 500, modemResponse);
  WaitForResponse("AT^SISS=0,\"srvType\",\"Socket\"\r", "OK", 500, modemResponse);
  WaitForResponse("AT^SISS=0,\"conId\",3\r", "OK", 500, modemResponse); // Set to use PDP context 3
  WaitForResponse("AT^SISS=0,\"address\",\"socktcp://m2.exosite.com:80\"\r", "OK", 500, modemResponse); // Configure socket to use TCP on port 80
  delay(10000);
  WaitForResponse("AT+CSQ\r", "OK", 500, modemResponse);  // Check signal strength
  WaitForResponse("AT+CGMR\r", "OK", 500, modemResponse);  // send command to modem to get firmware version
  String modemResp = "";  // activate PDP context
  delay(2000);
  Serial.println(getExoData("freqe", "0a2a70e7069f0481fb23bc3a72ba5c9a5edad4a3"));

}

int main(){
	init();
	Wire.begin();
	Serial.begin(115200);
	Serial.println("Begin!");
	
	DDRD |= 1 << PIND4;  								//LED ->set Port D -> PD4 to OUTPUT without changing current settings
	PORTD |= 1 << PIND4; 								//FLIP onboard LED ON

	DDRD |= 1 << PIND6;  								//set Port D -> PD6 to OUTPUT without changing current settings
	PORTD |= 1 << PIND6; 								//SET PD6 to HIGH -> turns ON onboard 4 Volt and 3.3v volt Regulators

	
	gpsSer.begin(9600);
	CV.begin(0x41);										// Default INA219 address is 0x40 JP2 bridged = 0x41
	CV.configure(INA219_RANGE_32V, INA219_GAIN_320MV, INA219_BUS_RES_12BIT, INA219_SHUNT_RES_12BIT_1S);
	CV.calibrate(0.1, 2);								// Calibrate INA219. Rshunt = 0.1 ohm, Max excepted current = 2A
	
	
	
	digitalWrite(23, LOW); //ON_OFF has internal 200k pullup resistor and needs to be driven low for >1s, don't accept default
  // Configure I/O pin 12 as output
	pinMode(23, OUTPUT);
	digitalWrite(23, LOW);  // Turn on Skywire modem
	delay(250); // modem requires >1s pulse
	pinMode(23, INPUT);  // Return I/O pin 12 to input/hi-Z state
	 


	digitalWrite(23, LOW); 
	pinMode(23, OUTPUT);
	digitalWrite(23, LOW);  
	delay(250);
	pinMode(23, INPUT);  
	String modemResponse = ""; // Modem responce to a command
	modemSetup();
	
	while (1){
		delay(200);
		Serial.println(getExoData("freqe", "0a2a70e7069f0481fb23bc3a72ba5c9a5edad4a3"));
		delay(8000);
		/*float temp = TH.readTemperature(); 				//Read Temperature
		float humid = TH.readHumidity();   				//Read Humiditiy
		Serial.println(temp, 1); 
		Serial.println(humid, 1);  						//Print Temperature and Humidity
		Serial.println(gpsSensor());					//Print GPS location
		Serial.print("Source voltage:   ");				//Print Power stats
		Serial.print(CV.readBusVoltage(), 5);
		Serial.println(" V");	

		Serial.print("Power Consumption:     ");
		Serial.print(CV.readBusPower(), 5);
		Serial.println(" W");

		Serial.print("Curent Draw: ");
		Serial.print(CV.readShuntCurrent(), 5);
		Serial.println(" A");
		delay(1000);
		
		//Serial.println(analogRead(A1)*5.0/1023);*/
	}
   return(0);

}
